# –∫–æ–¥/main.py

import subprocess
import shlex # –¢–∞–∫–∂–µ –∏–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º shlex –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤
import threading
import os

def run_sqlite_web():
    db_path = "/data/bot.db"
    port = os.environ.get("PORT", "80")
    host = "0.0.0.0"
    # –ò—Å–ø–æ–ª—å–∑—É–µ–º –∞—Ä–≥—É–º–µ–Ω—Ç --password –±–µ–∑ –∑–Ω–∞—á–µ–Ω–∏—è, –µ—Å–ª–∏ –ø–∞—Ä–æ–ª—å –Ω–µ –Ω—É–∂–µ–Ω –∏–ª–∏ –∑–∞–¥–∞–µ—Ç—Å—è –∏–Ω–∞—á–µ
    command = f"sqlite_web {shlex.quote(db_path)} --host {shlex.quote(host)} --port {shlex.quote(port)} --no-browser"

    print(f"Starting sqlite_web process with command: {command}", flush=True)
    try:
        # shell=True –º–æ–∂–µ—Ç –±—ã—Ç—å —Ä–∏—Å–∫–æ–≤–∞–Ω–Ω—ã–º, –ª—É—á—à–µ –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å —Å–ø–∏—Å–æ–∫ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤, –µ—Å–ª–∏ –≤–æ–∑–º–æ–∂–Ω–æ
        process = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, bufsize=1, universal_newlines=True)
        print(f"sqlite_web process started with PID: {process.pid}", flush=True)

        # –ß–∏—Ç–∞–µ–º stdout –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏
        for line in iter(process.stdout.readline, ''):
            print(f"[sqlite_web stdout]: {line.strip()}", flush=True)

        # –ß–∏—Ç–∞–µ–º stderr –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏ (–ø–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è stdout)
        for line in iter(process.stderr.readline, ''):
            print(f"[sqlite_web stderr]: {line.strip()}", flush=True)

        # –ñ–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø—Ä–æ—Ü–µ—Å—Å–∞ (–µ—Å–ª–∏ –æ–Ω –≤–¥—Ä—É–≥ –∑–∞–≤–µ—Ä—à–∏—Ç—Å—è)
        process.wait()
        print(f"sqlite_web process exited with code: {process.returncode}", flush=True)

    except FileNotFoundError:
         print(f"CRITICAL error: 'sqlite_web' command not found. Is it installed and in PATH?", flush=True)
    except Exception as e:
        print(f"CRITICAL error starting/running sqlite_web process: {e}", flush=True)

# –ó–∞–ø—É—Å–∫ –ø–æ—Ç–æ–∫–∞ –æ—Å—Ç–∞–µ—Ç—Å—è —Ç–µ–º –∂–µ
t = threading.Thread(target=run_sqlite_web, daemon=True)
t.start()

import asyncio
from aiogram import Bot, Dispatcher, types, F
from aiogram.filters import Command, StateFilter, CommandObject
from aiogram.exceptions import TelegramAPIError
from aiogram.enums import ParseMode
from aiogram.client.default import DefaultBotProperties
from aiogram.fsm.context import FSMContext
# --- –î–û–ë–ê–í–õ–Ø–ï–ú –ò–ú–ü–û–†–¢ State ---
from aiogram.fsm.state import State, StatesGroup
# --- –ö–û–ù–ï–¶ –ò–ó–ú–ï–ù–ï–ù–ò–Ø ---
from aiogram.fsm.storage.memory import MemoryStorage
from functools import partial
import pytz # –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ pytz –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω

# --- –ò–º–ø–æ—Ä—Ç—ã –∏–∑ –ø—Ä–æ–µ–∫—Ç–∞ ---
from config import (
    TOKEN, CHANNEL_ID, ADMIN_ID, UNIVERSE_ADVICE, BOT_LINK,
    TIMEZONE, NO_LOGS_USERS, DATA_DIR
)
# –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –∏ –°–µ—Ä–≤–∏—Å—ã
from database.db import Database
from modules.logging_service import LoggingService
from modules.notification_service import NotificationService
# –£–±–∏—Ä–∞–µ–º –∏–º–ø–æ—Ä—Ç State –æ—Ç—Å—é–¥–∞, —Ç.–∫. –æ–Ω —Ç–µ–ø–µ—Ä—å –≤—ã—à–µ
from modules.user_management import UserState, UserManager
from modules.ai_service import build_user_profile

# –ú–æ–¥—É–ª—å –ö–∞—Ä—Ç—ã –î–Ω—è
from modules.card_of_the_day import (
    get_main_menu, handle_card_request, process_initial_resource_callback,
    process_request_type_callback, process_request_text, process_initial_response,
    process_exploration_choice_callback, process_first_grok_response,
    process_second_grok_response, process_third_grok_response,
    process_final_resource_callback, process_recharge_method, process_card_feedback
)

# –ú–æ–¥—É–ª—å –í–µ—á–µ—Ä–Ω–µ–π –†–µ—Ñ–ª–µ–∫—Å–∏–∏
# –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è —Å—Ç–∞—Ä—Ç–∞ –∏ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ—Å—Ç–æ—è–Ω–∏–π
from modules.evening_reflection import (
    start_evening_reflection,
    process_good_moments,      # <--- –î–æ–±–∞–≤–ª–µ–Ω–æ
    process_gratitude,       # <--- –î–æ–±–∞–≤–ª–µ–Ω–æ
    process_hard_moments     # <--- –î–æ–±–∞–≤–ª–µ–Ω–æ
    # reflection_router –±–æ–ª—å—à–µ –Ω–µ –∏–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –∑–¥–µ—Å—å
)

# --- –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –∏–º–ø–æ—Ä—Ç—ã ---
import random
from datetime import datetime, timedelta, time, date # –î–æ–±–∞–≤–ª—è–µ–º time, date
import os
import json
import logging
import sqlite3

# --- –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è ---
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(name)s - %(message)s')
logger = logging.getLogger(__name__)

# --- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ---
bot = Bot(token=TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
storage = MemoryStorage()
dp = Dispatcher(storage=storage)
os.makedirs(DATA_DIR, exist_ok=True)
db_path = os.path.join(DATA_DIR, "bot.db")
logger.info(f"Initializing database at: {db_path}")
print(f"Initializing database at: {db_path}")
try:
    db = Database(path=db_path)
    db.conn.execute("SELECT 1"); logger.info(f"Database connection established successfully: {db.conn}")
    db.bot = bot
except (sqlite3.Error, Exception) as e:
    logger.exception(f"CRITICAL: Database initialization failed at {db_path}: {e}")
    print(f"CRITICAL: Database initialization failed at {db_path}: {e}"); raise SystemExit(f"Database failed: {e}")
logging_service = LoggingService(db)
notifier = NotificationService(bot, db)
user_manager = UserManager(db)


# --- Middleware ---
class SubscriptionMiddleware:
    async def __call__(self, handler, event, data):
        return await handler(event, data)
        if isinstance(event, (types.Message, types.CallbackQuery)):
            user = event.from_user
            if not user or user.is_bot or user.id == ADMIN_ID:
                return await handler(event, data)
            user_id = user.id
            try:
                user_status = await bot.get_chat_member(chat_id=CHANNEL_ID, user_id=user_id)
                allowed_statuses = ["member", "administrator", "creator"]
                if user_status.status not in allowed_statuses:
                    user_db_data = db.get_user(user_id); name = user_db_data.get("name") if user_db_data else None
                    link = f"https://t.me/{CHANNEL_ID.lstrip('@')}"
                    text = f"{name}, —Ä–∞–¥ –≤–∏–¥–µ—Ç—å —Ç–µ–±—è. ‚ú® –î–ª—è –Ω–∞—à–µ–π —Å–æ–≤–º–µ—Å—Ç–Ω–æ–π —Ä–∞–±–æ—Ç—ã, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ <a href='{link}'>–∫–∞–Ω–∞–ª –∞–≤—Ç–æ—Ä–∞</a>. –≠—Ç–æ –≤–∞–∂–Ω–æ –¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞. –ü–æ—Å–ª–µ –ø–æ–¥–ø–∏—Å–∫–∏ –ø—Ä–æ—Å—Ç–æ –Ω–∞–∂–º–∏ /start." if name else f"–†–∞–¥ –≤–∏–¥–µ—Ç—å —Ç–µ–±—è. ‚ú® –î–ª—è –Ω–∞—à–µ–π —Å–æ–≤–º–µ—Å—Ç–Ω–æ–π —Ä–∞–±–æ—Ç—ã, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ <a href='{link}'>–∫–∞–Ω–∞–ª –∞–≤—Ç–æ—Ä–∞</a>. –≠—Ç–æ –≤–∞–∂–Ω–æ –¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞. –ü–æ—Å–ª–µ –ø–æ–¥–ø–∏—Å–∫–∏ –ø—Ä–æ—Å—Ç–æ –Ω–∞–∂–º–∏ /start."
                    if isinstance(event, types.Message):
                        await event.answer(text, disable_web_page_preview=True)
                    elif isinstance(event, types.CallbackQuery):
                        await event.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ –∫–∞–Ω–∞–ª.", show_alert=True)
                        await event.message.answer(text, disable_web_page_preview=True)
                    return
            except Exception as e:
                logger.error(f"Subscription check failed for user {user_id}: {e}")
                error_text = f"–ù–µ –ø–æ–ª—É—á–∞–µ—Ç—Å—è –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Ç–≤–æ—é –ø–æ–¥–ø–∏—Å–∫—É –Ω–∞ –∫–∞–Ω–∞–ª {CHANNEL_ID}. –£–±–µ–¥–∏—Å—å, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, —á—Ç–æ —Ç—ã –ø–æ–¥–ø–∏—Å–∞–Ω–∞, –∏ –ø–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞ —á–µ—Ä–µ–∑ /start."
                if isinstance(event, types.Message): await event.answer(error_text)
                elif isinstance(event, types.CallbackQuery): await event.answer("–ù–µ —É–¥–∞–µ—Ç—Å—è –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É.", show_alert=False); await event.message.answer(error_text)
                return
        return await handler(event, data)


# --- –û–±—â–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–ø—Ä–æ—Å–∞ –≤—Ä–µ–º–µ–Ω–∏ ---
async def ask_for_time(message: types.Message, state: FSMContext, prompt_text: str, next_state: State):
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∑–∞–ø—Ä–æ—Å–æ–º –≤—Ä–µ–º–µ–Ω–∏ –∏ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç —Å–ª–µ–¥—É—é—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ."""
    await message.answer(prompt_text)
    await state.set_state(next_state)

# --- –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã—Ö –∫–æ–º–∞–Ω–¥ ---
def make_start_handler(db, logger_service, user_manager):
    async def wrapped_handler(message: types.Message, state: FSMContext, command: CommandObject | None = None):
        await state.clear()
        user_id = message.from_user.id
        username = message.from_user.username or ""
        args = command.args if command else ""
        await logger_service.log_action(user_id, "start_command", {"args": args})
        user_data = db.get_user(user_id)
        if user_data.get("username") != username: db.update_user(user_id, {"username": username})
        if args and args.startswith("ref_"):
            try:
                referrer_id = int(args[4:])
                if referrer_id != user_id:
                    if db.add_referral(referrer_id, user_id):
                         referrer_data = db.get_user(referrer_id)
                         if referrer_data and not referrer_data.get("bonus_available"):
                             await user_manager.set_bonus_available(referrer_id, True)
                             ref_name = referrer_data.get("name", "–î—Ä—É–≥")
                             text = f"{ref_name}, —É—Ä–∞! üéâ –ö—Ç–æ-—Ç–æ –≤–æ—Å–ø–æ–ª—å–∑–æ–≤–∞–ª—Å—è —Ç–≤–æ–µ–π —Å—Å—ã–ª–∫–æ–π! –¢–µ–ø–µ—Ä—å —Ç–µ–±–µ –¥–æ—Å—Ç—É–ø–Ω–∞ 'üíå –ü–æ–¥—Å–∫–∞–∑–∫–∞ –í—Å–µ–ª–µ–Ω–Ω–æ–π' –≤ –º–µ–Ω—é."
                             try:
                                 await bot.send_message(referrer_id, text, reply_markup=await get_main_menu(referrer_id, db))
                                 await logger_service.log_action(referrer_id, "referral_bonus_granted", {"referred_user": user_id})
                             except Exception as send_err:
                                 logger.error(f"Failed to send referral bonus message to {referrer_id}: {send_err}")
            except (ValueError, TypeError, IndexError) as ref_err:
                logger.warning(f"Invalid referral code processing '{args}' from user {user_id}: {ref_err}")
        user_name = user_data.get("name")
        if not user_name:
            await message.answer("–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π! ‚ú® –û—á–µ–Ω—å —Ä–∞–¥ –Ω–∞—à–µ–º—É –∑–Ω–∞–∫–æ–º—Å—Ç–≤—É. –ü–æ–¥—Å–∫–∞–∂–∏, –∫–∞–∫ –º–Ω–µ –ª—É—á—à–µ –∫ —Ç–µ–±–µ –æ–±—Ä–∞—â–∞—Ç—å—Å—è?",
                                 reply_markup=types.InlineKeyboardMarkup(inline_keyboard=[[types.InlineKeyboardButton(text="–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å", callback_data="skip_name")]]))
            await state.set_state(UserState.waiting_for_name)
        else:
            await message.answer(f"{user_name}, —Å–Ω–æ–≤–∞ —Ä–∞–¥ —Ç–µ–±—è –≤–∏–¥–µ—Ç—å! üëã –ì–æ—Ç–æ–≤–∞ –ø–æ—Ä–∞–±–æ—Ç–∞—Ç—å —Å –∫–∞—Ä—Ç–æ–π –¥–Ω—è –∏–ª–∏ –ø–æ–¥–≤–µ—Å—Ç–∏ –∏—Ç–æ–≥?",
                                 reply_markup=await get_main_menu(user_id, db))
    return wrapped_handler

def make_remind_handler(db, logger_service, user_manager):
    async def wrapped_handler(message: types.Message, state: FSMContext):
        user_id = message.from_user.id
        user_data = db.get_user(user_id)
        name = user_data.get("name", "–î—Ä—É–≥")
        morning_reminder = user_data.get("reminder_time")
        evening_reminder = user_data.get("reminder_time_evening")
        morning_text = f"–ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ '–ö–∞—Ä—Ç–∞ –¥–Ω—è' ‚ú®: <b>{morning_reminder}</b> –ú–°–ö" if morning_reminder else "–ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ '–ö–∞—Ä—Ç–∞ –¥–Ω—è' ‚ú®: <b>–æ—Ç–∫–ª—é—á–µ–Ω–æ</b>"
        evening_text = f"–ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ '–ò—Ç–æ–≥ –¥–Ω—è' üåô: <b>{evening_reminder}</b> –ú–°–ö" if evening_reminder else "–ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ '–ò—Ç–æ–≥ –¥–Ω—è' üåô: <b>–æ—Ç–∫–ª—é—á–µ–Ω–æ</b>"
        purpose_text = "‚è∞ –ù–∞—Å—Ç—Ä–æ–∏–º –µ–∂–µ–¥–Ω–µ–≤–Ω—ã–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è?"
        instruction_text = ("–°–Ω–∞—á–∞–ª–∞ –≤–≤–µ–¥–∏ —É–¥–æ–±–Ω–æ–µ –≤—Ä–µ–º—è –¥–ª—è <b>—É—Ç—Ä–µ–Ω–Ω–µ–≥–æ</b> –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è '–ö–∞—Ä—Ç–∞ –¥–Ω—è' –≤ —Ñ–æ—Ä–º–∞—Ç–µ <b>–ß–ß:–ú–ú</b> (–Ω–∞–ø—Ä–∏–º–µ—Ä, <code>09:00</code>).\n–ò–ª–∏ –Ω–∞–ø–∏—à–∏ <code>–≤—ã–∫–ª</code>, —á—Ç–æ–±—ã –æ—Ç–∫–ª—é—á–∏—Ç—å —ç—Ç–æ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ.\n\n"
                           f"<u>–¢–µ–∫—É—â–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏:</u>\n- {morning_text}\n- {evening_text}")
        text = f"{name}, –ø—Ä–∏–≤–µ—Ç!\n\n{purpose_text}\n\n{instruction_text}"
        await message.answer(text, reply_markup=await get_main_menu(user_id, db))
        await state.set_state(UserState.waiting_for_morning_reminder_time)
        await logger_service.log_action(user_id, "remind_command_invoked")
    return wrapped_handler

def make_broadcast_handler(db: Database, logger_service: LoggingService):
    async def wrapped_handler(message: types.Message):
        user_id = message.from_user.id
        if user_id != ADMIN_ID:
            await message.reply("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
            return
        broadcast_text = message.text[len("/broadcast"):].strip()
        if not broadcast_text:
            await message.reply("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏ –ø–æ—Å–ª–µ –∫–æ–º–∞–Ω–¥—ã.\n"
                                "–ü—Ä–∏–º–µ—Ä: `/broadcast –ü—Ä–∏–≤–µ—Ç! –£ –±–æ—Ç–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è!`")
            return
        text_to_send = """–ü—Ä–∏–≤–µ—Ç! –ù–∞–¥–µ—é—Å—å, —É –≤–∞—Å –≤—Å–µ —Ö–æ—Ä–æ—à–æ. ‚ú®

–•–æ—á—É –ø–æ–¥–µ–ª–∏—Ç—å—Å—è –Ω–æ–≤–æ—Å—Ç—è–º–∏: —è –Ω–µ–º–Ω–æ–≥–æ –æ–±–Ω–æ–≤–∏–ª—Å—è, —á—Ç–æ–±—ã –Ω–∞—à–∞ —Ä–∞–±–æ—Ç–∞ —Å –∫–∞—Ä—Ç–∞–º–∏ –∏ —Å–∞–º–æ—Ä–µ—Ñ–ª–µ–∫—Å–∏–µ–π —Å—Ç–∞–ª–∞ –µ—â–µ –≥–ª—É–±–∂–µ –∏ –ø–æ–ª–µ–∑–Ω–µ–µ!

1) –£ –º–µ–Ω—è –Ω–æ–≤–æ–µ –∏–º—è ‚Äì "–†–µ—Å—É—Ä—Å–Ω—ã–π –ø–æ–º–æ—â–Ω–∏–∫". –ú–Ω–µ –∫–∞–∂–µ—Ç—Å—è, –æ–Ω–æ –ª—É—á—à–µ –æ—Ç—Ä–∞–∂–∞–µ—Ç —Ç–æ, —á–µ–º —è –º–æ–≥—É –±—ã—Ç—å –¥–ª—è –≤–∞—Å –ø–æ–ª–µ–∑–µ–Ω. üòä

2) –¢–µ–ø–µ—Ä—å —è —É–º–µ—é —Å–æ—Å—Ç–∞–≤–ª—è—Ç—å "–ü—Ä–æ—Ñ–∏–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è" (–∑–∞–≥–ª—è–Ω–∏—Ç–µ —á–µ—Ä–µ–∑ –∫–æ–º–∞–Ω–¥—É /user_profile!), –≥–¥–µ –±–µ—Ä–µ–∂–Ω–æ —Å–æ–±–∏—Ä–∞—é—Ç—Å—è –≤–∞–∂–Ω—ã–µ –º–æ–º–µ–Ω—Ç—ã –Ω–∞—à–µ–≥–æ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è. –£–∑–Ω–∞–π—Ç–µ —Å–µ–±—è –Ω–µ–º–Ω–æ–≥–æ –ª—É—á—à–µ!

3) –ü–æ—è–≤–∏–ª—Å—è —É—é—Ç–Ω—ã–π –≤–µ—á–µ—Ä–Ω–∏–π —Ä–∏—Ç—É–∞–ª "üåô –ò—Ç–æ–≥ –¥–Ω—è" ‚Äì –≤—Å–µ–≥–æ –ø–∞—Ä–∞ –º–∏–Ω—É—Ç, —á—Ç–æ–±—ã –º—è–≥–∫–æ –∑–∞–≤–µ—Ä—à–∏—Ç—å –¥–µ–Ω—å –∏ –ø–æ–∑–∞–±–æ—Ç–∏—Ç—å—Å—è –æ —Å–µ–±–µ.

–û—á–µ–Ω—å —Ö–æ—á–µ—Ç—Å—è —Å–Ω–æ–≤–∞ –ø–æ–æ–±—â–∞—Ç—å—Å—è! –ù–∞–∂–º–∏—Ç–µ /start, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å –æ–±–Ω–æ–≤–ª–µ–Ω–Ω–æ–µ –º–µ–Ω—é –∏ –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –Ω–æ–≤–∏–Ω–∫–∏.

–° –Ω–µ—Ç–µ—Ä–ø–µ–Ω–∏–µ–º –∂–¥—É –≤—Å—Ç—Ä–µ—á–∏!
–í–∞—à –†–µ—Å—É—Ä—Å–Ω—ã–π –ø–æ–º–æ—â–Ω–∏–∫ ‚ù§Ô∏è"""
        users = [457463804, 478901963, 517423026, 644771890, 683970407, 684097293, 685995409, 806894927, 834325767, 1068630660, 1123817690, 1159751971, 1264280911, 1348873495, 1664012269, 1821666039, 1853568101, 1887924167, 5741110759,6288394996, 865377684, 171507422]
        if not users:
            await message.reply("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è —Ç–µ—Å—Ç–æ–≤–æ–π —Ä–∞—Å—Å—ã–ª–∫–∏.")
            return
        await message.reply(f"–ù–∞—á–∏–Ω–∞—é –¢–ï–°–¢–û–í–£–Æ —Ä–∞—Å—Å—ã–ª–∫—É —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è {len(users)} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (ID: {users[0]})...")
        await logger_service.log_action(user_id, "broadcast_test_started", {"target_user_id": users[0], "text_preview": text_to_send[:50]})
        success_count = 0
        fail_count = 0
        failed_users = []
        for target_user_id in users:
            try:
                await bot.send_message(target_user_id, text_to_send, parse_mode=ParseMode.HTML, disable_web_page_preview=True)
                success_count += 1
            except TelegramAPIError as e:
                fail_count += 1
                failed_users.append(target_user_id)
                logger.error(f"Failed to send broadcast to {target_user_id}: {e}")
                await logger_service.log_action(ADMIN_ID, "broadcast_failed_user", {"target_user_id": target_user_id, "error": str(e)})
            except Exception as e:
                fail_count += 1
                failed_users.append(target_user_id)
                logger.error(f"Unexpected error sending broadcast to {target_user_id}: {e}", exc_info=True)
                await logger_service.log_action(ADMIN_ID, "broadcast_failed_user", {"target_user_id": target_user_id, "error": f"Unexpected: {str(e)}"})
            await asyncio.sleep(0.05)
        result_text = f"‚úÖ –¢–µ—Å—Ç–æ–≤–∞—è —Ä–∞—Å—Å—ã–ª–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!\n–£—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: {success_count}\n–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å: {fail_count}"
        if failed_users:
            result_text += f"\nID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å –æ—à–∏–±–∫–æ–π: {failed_users[0]}"
        await message.reply(result_text)
        await logger_service.log_action(ADMIN_ID, "broadcast_test_finished", {"success": success_count, "failed": fail_count})
    return wrapped_handler

def make_process_morning_reminder_time_handler(db, logger_service, user_manager):
     async def wrapped_handler(message: types.Message, state: FSMContext):
        user_id = message.from_user.id
        name = db.get_user(user_id).get("name", "–î—Ä—É–≥")
        input_text = message.text.strip().lower()
        morning_time_to_save = None
        if input_text == "–≤—ã–∫–ª":
            morning_time_to_save = None
            await logger_service.log_action(user_id, "reminder_set_morning", {"time": "disabled"})
            await message.reply("–•–æ—Ä–æ—à–æ, —É—Ç—Ä–µ–Ω–Ω–µ–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ '–ö–∞—Ä—Ç–∞ –¥–Ω—è' –æ—Ç–∫–ª—é—á–µ–Ω–æ.")
        else:
            try:
                reminder_dt = datetime.strptime(input_text, "%H:%M")
                morning_time_to_save = reminder_dt.strftime("%H:%M")
                await logger_service.log_action(user_id, "reminder_set_morning", {"time": morning_time_to_save})
                await message.reply(f"–£—Ç—Ä–µ–Ω–Ω–µ–µ –≤—Ä–µ–º—è <code>{morning_time_to_save}</code> –ø—Ä–∏–Ω—è—Ç–æ.")
            except ValueError:
                await message.reply(f"{name}, –Ω–µ —Å–æ–≤—Å–µ–º –ø–æ–Ω—è–ª –≤—Ä–µ–º—è. üï∞Ô∏è –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏ –≤—Ä–µ–º—è –¥–ª—è <b>—É—Ç—Ä–µ–Ω–Ω–µ–≥–æ</b> –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ –ß–ß:–ú–ú (–Ω–∞–ø—Ä–∏–º–µ—Ä, <code>08:30</code>) –∏–ª–∏ –Ω–∞–ø–∏—à–∏ <code>–≤—ã–∫–ª</code>.")
                return
        await state.update_data(morning_time=morning_time_to_save)
        evening_prompt = "–¢–µ–ø–µ—Ä—å –≤–≤–µ–¥–∏ –≤—Ä–µ–º—è –¥–ª—è <b>–≤–µ—á–µ—Ä–Ω–µ–≥–æ</b> –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è '–ò—Ç–æ–≥ –¥–Ω—è' üåô (–ß–ß:–ú–ú) –∏–ª–∏ –Ω–∞–ø–∏—à–∏ <code>–≤—ã–∫–ª</code>."
        await ask_for_time(message, state, evening_prompt, UserState.waiting_for_evening_reminder_time)
     return wrapped_handler

def make_process_evening_reminder_time_handler(db, logger_service, user_manager):
     async def wrapped_handler(message: types.Message, state: FSMContext):
        user_id = message.from_user.id
        name = db.get_user(user_id).get("name", "–î—Ä—É–≥")
        input_text = message.text.strip().lower()
        evening_time_to_save = None
        state_data = await state.get_data()
        morning_time = state_data.get("morning_time")
        if input_text == "–≤—ã–∫–ª":
            evening_time_to_save = None
            await logger_service.log_action(user_id, "reminder_set_evening", {"time": "disabled"})
        else:
            try:
                reminder_dt = datetime.strptime(input_text, "%H:%M")
                evening_time_to_save = reminder_dt.strftime("%H:%M")
                await logger_service.log_action(user_id, "reminder_set_evening", {"time": evening_time_to_save})
            except ValueError:
                await message.reply(f"{name}, –Ω–µ –ø–æ–Ω—è–ª –≤—Ä–µ–º—è. üï∞Ô∏è –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏ –≤—Ä–µ–º—è –¥–ª—è <b>–≤–µ—á–µ—Ä–Ω–µ–≥–æ</b> –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è (–ß–ß:–ú–ú) –∏–ª–∏ –Ω–∞–ø–∏—à–∏ <code>–≤—ã–∫–ª</code>.")
                return
        try:
            await user_manager.set_reminder(user_id, morning_time, evening_time_to_save)
            await logger_service.log_action(user_id, "reminders_saved_total", {"morning_time": morning_time, "evening_time": evening_time_to_save})
            morning_confirm = f"'–ö–∞—Ä—Ç–∞ –¥–Ω—è' ‚ú®: <b>{morning_time}</b> –ú–°–ö" if morning_time else "'–ö–∞—Ä—Ç–∞ –¥–Ω—è' ‚ú®: <b>–æ—Ç–∫–ª—é—á–µ–Ω–æ</b>"
            evening_confirm = f"'–ò—Ç–æ–≥ –¥–Ω—è' üåô: <b>{evening_time_to_save}</b> –ú–°–ö" if evening_time_to_save else "'–ò—Ç–æ–≥ –¥–Ω—è' üåô: <b>–æ—Ç–∫–ª—é—á–µ–Ω–æ</b>"
            text = f"{name}, –≥–æ—Ç–æ–≤–æ! ‚úÖ\n–ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã:\n- {morning_confirm}\n- {evening_confirm}"
            await message.answer(text, reply_markup=await get_main_menu(user_id, db))
            await state.clear()
        except Exception as e:
            logger.error(f"Failed to save reminders for user {user_id}: {e}", exc_info=True)
            await message.answer("–û–π, –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫...")
            await state.clear()
     return wrapped_handler

def make_remind_off_handler(db, logger_service, user_manager):
     async def wrapped_handler(message: types.Message, state: FSMContext):
         user_id = message.from_user.id
         current_state = await state.get_state()
         if current_state in [UserState.waiting_for_morning_reminder_time, UserState.waiting_for_evening_reminder_time]:
             await state.clear()
         try:
             await user_manager.clear_reminders(user_id)
             await logger_service.log_action(user_id, "reminders_cleared")
             name = db.get_user(user_id).get("name", "–î—Ä—É–≥")
             text = f"{name}, —è –æ—Ç–∫–ª—é—á–∏–ª <b>–≤—Å–µ</b> –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –¥–ª—è —Ç–µ–±—è (—É—Ç—Ä–µ–Ω–Ω–µ–µ –∏ –≤–µ—á–µ—Ä–Ω–µ–µ). –ï—Å–ª–∏ –∑–∞—Ö–æ—á–µ—à—å –≤–∫–ª—é—á–∏—Ç—å —Å–Ω–æ–≤–∞, –∏—Å–ø–æ–ª—å–∑—É–π /remind."
             await message.answer(text, reply_markup=await get_main_menu(user_id, db))
         except Exception as e:
             logger.error(f"Failed to disable reminders for user {user_id}: {e}", exc_info=True)
             await message.answer("–û–π, –Ω–µ –ø–æ–ª—É—á–∏–ª–æ—Å—å –æ—Ç–∫–ª—é—á–∏—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è...")
     return wrapped_handler

def make_share_handler(db, logger_service):
    async def wrapped_handler(message: types.Message):
        user_id = message.from_user.id
        name = db.get_user(user_id).get("name", "–î—Ä—É–≥")
        ref_link = f"{BOT_LINK}?start=ref_{user_id}"
        text = (f"{name}, —Ö–æ—á–µ—à—å –ø–æ–¥–µ–ª–∏—Ç—å—Å—è —ç—Ç–∏–º –±–æ—Ç–æ–º —Å –¥—Ä—É–∑—å—è–º–∏?\n–í–æ—Ç —Ç–≤–æ—è –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω–∞—è —Å—Å—ã–ª–∫–∞: {ref_link}\n\n"
               f"–ö–æ–≥–¥–∞ –∫—Ç–æ-–Ω–∏–±—É–¥—å –ø–µ—Ä–µ–π–¥–µ—Ç –ø–æ –Ω–µ–π –∏ –Ω–∞—á–Ω–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –±–æ—Ç–∞, —Ç—ã –ø–æ–ª—É—á–∏—à—å –¥–æ—Å—Ç—É–ø –∫ 'üíå –ü–æ–¥—Å–∫–∞–∑–∫–µ –í—Å–µ–ª–µ–Ω–Ω–æ–π' –≤ –≥–ª–∞–≤–Ω–æ–º –º–µ–Ω—é! ‚ú®")
        await message.answer(text, reply_markup=await get_main_menu(user_id, db))
        await logger_service.log_action(user_id, "share_command")
    return wrapped_handler

def make_name_handler(db, logger_service, user_manager):
     async def wrapped_handler(message: types.Message, state: FSMContext):
         user_id = message.from_user.id
         name = db.get_user(user_id).get("name")
         text = f"–¢–≤–æ–µ —Ç–µ–∫—É—â–µ–µ –∏–º—è: <b>{name}</b>.\n–•–æ—á–µ—à—å –∏–∑–º–µ–Ω–∏—Ç—å?" if name else "–ö–∞–∫ —Ç–µ–±—è –∑–æ–≤—É—Ç?"
         text += "\n–í–≤–µ–¥–∏ –Ω–æ–≤–æ–µ –∏–º—è –∏–ª–∏ –Ω–∞–∂–º–∏ '–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å', –µ—Å–ª–∏ –Ω–µ —Ö–æ—á–µ—à—å —É–∫–∞–∑—ã–≤–∞—Ç—å."
         await message.answer(text, reply_markup=types.InlineKeyboardMarkup(inline_keyboard=[[types.InlineKeyboardButton(text="–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å", callback_data="skip_name")]]))
         await state.set_state(UserState.waiting_for_name)
         await logger_service.log_action(user_id, "name_change_initiated")
     return wrapped_handler

def make_feedback_handler(db, logger_service):
     async def wrapped_handler(message: types.Message, state: FSMContext):
         user_id = message.from_user.id
         name = db.get_user(user_id).get("name", "–î—Ä—É–≥")
         text = (f"{name}, —Ö–æ—á–µ—à—å –ø–æ–¥–µ–ª–∏—Ç—å—Å—è –∏–¥–µ–µ–π, –∫–∞–∫ —Å–¥–µ–ª–∞—Ç—å –º–µ–Ω—è –ª—É—á—à–µ, –∏–ª–∏ —Ä–∞—Å—Å–∫–∞–∑–∞—Ç—å –æ –ø—Ä–æ–±–ª–µ–º–µ?\n–Ø –≤–Ω–∏–º–∞—Ç–µ–ª—å–Ω–æ —á–∏—Ç–∞—é –≤—Å–µ —Å–æ–æ–±—â–µ–Ω–∏—è! –ù–∞–ø–∏—à–∏ –∑–¥–µ—Å—å –≤—Å–µ, —á—Ç–æ –¥—É–º–∞–µ—à—å.")
         await message.answer(text, reply_markup=await get_main_menu(user_id, db))
         await state.set_state(UserState.waiting_for_feedback)
         await logger_service.log_action(user_id, "feedback_initiated")
     return wrapped_handler

def make_user_profile_handler(db, logger_service):
     async def wrapped_handler(message: types.Message, state: FSMContext):
        await state.clear()
        user_id = message.from_user.id
        name = db.get_user(user_id).get("name", "–î—Ä—É–≥")
        await logger_service.log_action(user_id, "user_profile_viewed")
        profile = await build_user_profile(user_id, db)
        mood = profile.get("mood", "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ")
        mood_trend_list = [m for m in profile.get("mood_trend", []) if m != "unknown"]
        mood_trend = " ‚Üí ".join(mood_trend_list) if mood_trend_list else "–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö"
        themes_list = profile.get("themes", [])
        themes = ", ".join(themes_list) if themes_list and themes_list != ["–Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ"] else "–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö"
        initial_resource = profile.get("initial_resource") or "–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö"
        final_resource = profile.get("final_resource") or "–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö"
        recharge_method = profile.get("recharge_method") or "–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö"
        last_reflection_date = profile.get("last_reflection_date") or "–ø–æ–∫–∞ –Ω–µ –±—ã–ª–æ"
        reflection_count = profile.get("reflection_count", 0)
        response_count = profile.get("response_count", 0)
        days_active = profile.get("days_active", 0)
        total_cards_drawn = profile.get("total_cards_drawn", 0)
        last_updated_dt = profile.get("last_updated")
        last_updated = last_updated_dt.astimezone(TIMEZONE).strftime("%Y-%m-%d %H:%M") if isinstance(last_updated_dt, datetime) else "–Ω–µ –æ–±–Ω–æ–≤–ª—è–ª—Å—è"
        text = (
             f"üìä <b>{name}, —Ç–≤–æ–π –ø—Ä–æ—Ñ–∏–ª—å –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è:</b>\n\n"
             f"üë§ <b>–°–æ—Å—Ç–æ—è–Ω–∏–µ & –¢–µ–º—ã:</b>\n  - –ù–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ (–ø–æ—Å–ª–µ–¥–Ω–µ–µ): {mood}\n  - –¢—Ä–µ–Ω–¥ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è: {mood_trend}\n  - –ö–ª—é—á–µ–≤—ã–µ —Ç–µ–º—ã (–∏–∑ –∫–∞—Ä—Ç –∏ —Ä–µ—Ñ–ª–µ–∫—Å–∏–π): {themes}\n\n"
             f"üåø <b>–†–µ—Å—É—Ä—Å (–ø–æ—Å–ª–µ–¥–Ω—è—è '–ö–∞—Ä—Ç–∞ –¥–Ω—è'):</b>\n  - –í –Ω–∞—á–∞–ª–µ: {initial_resource}\n  - –í –∫–æ–Ω—Ü–µ: {final_resource}\n  - –°–ø–æ—Å–æ–± –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è: {recharge_method}\n\n"
             f"üåô <b>–í–µ—á–µ—Ä–Ω—è—è –†–µ—Ñ–ª–µ–∫—Å–∏—è:</b>\n  - –ü–æ—Å–ª–µ–¥–Ω–∏–π –∏—Ç–æ–≥ –ø–æ–¥–≤–µ–¥–µ–Ω: {last_reflection_date}\n  - –í—Å–µ–≥–æ –∏—Ç–æ–≥–æ–≤ –ø–æ–¥–≤–µ–¥–µ–Ω–æ: {reflection_count}\n\n"
             f"üìà <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ê–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏:</b>\n  - –û—Ç–≤–µ—Ç–æ–≤ –≤ –¥–∏–∞–ª–æ–≥–∞—Ö —Å –∫–∞—Ä—Ç–æ–π: {response_count}\n  - –í—Å–µ–≥–æ –∫–∞—Ä—Ç –≤—ã—Ç—è–Ω—É—Ç–æ: {total_cards_drawn}\n  - –î–Ω–µ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏: {days_active}\n\n"
             f"‚è± <b>–ü—Ä–æ—Ñ–∏–ª—å –æ–±–Ω–æ–≤–ª–µ–Ω:</b> {last_updated} –ú–°–ö\n\n"
             f"<i>–≠—Ç–æ—Ç –ø—Ä–æ—Ñ–∏–ª—å –ø–æ–º–æ–≥–∞–µ—Ç –º–Ω–µ –ª—É—á—à–µ –ø–æ–Ω–∏–º–∞—Ç—å —Ç–µ–±—è. –û–Ω —É—á–∏—Ç—ã–≤–∞–µ—Ç —Ç–≤–æ–∏ –æ—Ç–≤–µ—Ç—ã –≤ '–ö–∞—Ä—Ç–µ –¥–Ω—è' –∏ '–ò—Ç–æ–≥–∞—Ö –¥–Ω—è'.</i>"
         )
        await message.answer(text, reply_markup=await get_main_menu(user_id, db))
     return wrapped_handler

def make_admin_user_profile_handler(db, logger_service):
     async def wrapped_handler(message: types.Message):
         user_id = message.from_user.id
         if user_id != ADMIN_ID: await message.answer("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É."); return
         args = message.text.split()
         if len(args) < 2:
             await message.answer("–£–∫–∞–∂–∏ ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: /admin_user_profile <user_id>")
             return
         try:
             target_user_id = int(args[1])
         except ValueError:
             await message.answer("ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.")
             return
         user_info = db.get_user(target_user_id)
         if not user_info:
             await message.answer(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å ID {target_user_id} –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ —Ç–∞–±–ª–∏—Ü–µ users.")
             return
         profile = await build_user_profile(target_user_id, db)
         name = user_info.get("name", "N/A")
         username = user_info.get("username", "N/A")
         mood = profile.get("mood", "N/A")
         mood_trend_list = [m for m in profile.get("mood_trend", []) if m != "unknown"]
         mood_trend = " ‚Üí ".join(mood_trend_list) if mood_trend_list else "N/A"
         themes_list = profile.get("themes", [])
         themes = ", ".join(themes_list) if themes_list and themes_list != ["–Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ"] else "N/A"
         initial_resource = profile.get("initial_resource") or "N/A"
         final_resource = profile.get("final_resource") or "N/A"
         recharge_method = profile.get("recharge_method") or "N/A"
         last_reflection_date = profile.get("last_reflection_date") or "N/A"
         reflection_count = profile.get("reflection_count", 0)
         response_count = profile.get("response_count", 0)
         days_active = profile.get("days_active", 0)
         total_cards_drawn = profile.get("total_cards_drawn", 0)
         last_updated_dt = profile.get("last_updated")
         last_updated = last_updated_dt.astimezone(TIMEZONE).strftime("%Y-%m-%d %H:%M") if isinstance(last_updated_dt, datetime) else "N/A"
         text = (
             f"üë§ <b>–ü—Ä–æ—Ñ–∏–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:</b> <code>{target_user_id}</code>\n   –ò–º—è: {name}, –ù–∏–∫: @{username}\n\n"
             f"<b>–°–æ—Å—Ç–æ—è–Ω–∏–µ & –¢–µ–º—ã:</b>\n  –ù–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ: {mood}\n  –¢—Ä–µ–Ω–¥: {mood_trend}\n  –¢–µ–º—ã: {themes}\n\n"
             f"<b>–†–µ—Å—É—Ä—Å (–ø–æ—Å–ª–µ–¥–Ω–∏–π '–ö–∞—Ä—Ç–∞ –¥–Ω—è'):</b>\n  –ù–∞—á–∞–ª–æ: {initial_resource}\n  –ö–æ–Ω–µ—Ü: {final_resource}\n  –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ: {recharge_method}\n\n"
             f"<b>–í–µ—á–µ—Ä–Ω—è—è –†–µ—Ñ–ª–µ–∫—Å–∏—è:</b>\n  –ü–æ—Å–ª–µ–¥–Ω–∏–π –∏—Ç–æ–≥: {last_reflection_date}\n  –í—Å–µ–≥–æ –∏—Ç–æ–≥–æ–≤: {reflection_count}\n\n"
             f"<b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ê–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏:</b>\n  –û—Ç–≤–µ—Ç–æ–≤ (–∫–∞—Ä—Ç–∞): {response_count}\n  –ö–∞—Ä—Ç –≤—ã—Ç—è–Ω—É—Ç–æ: {total_cards_drawn}\n  –î–Ω–µ–π –∞–∫—Ç–∏–≤.: {days_active}\n\n"
             f"<b>–û–±–Ω–æ–≤–ª–µ–Ω–æ:</b> {last_updated} –ú–°–ö"
         )
         await message.answer(text)
         await logger_service.log_action(user_id, "admin_user_profile_viewed", {"target_user_id": target_user_id})
     return wrapped_handler

def make_users_handler(db, logger_service):
    async def wrapped_handler(message: types.Message):
        user_id = message.from_user.id
        if user_id != ADMIN_ID: await message.answer("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É."); return
        users = db.get_all_users()
        if not users:
            await message.answer("–í –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö –Ω–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.")
            return
        excluded_users = set(NO_LOGS_USERS) if NO_LOGS_USERS else set()
        filtered_users = [uid for uid in users if uid not in excluded_users]
        if not filtered_users:
            await message.answer("–ù–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è (–≤—Å–µ –∏—Å–∫–ª—é—á–µ–Ω—ã –∏–ª–∏ —Å–ø–∏—Å–æ–∫ –ø—É—Å—Ç).")
            return
        user_list = []
        for uid in filtered_users:
            user_data = db.get_user(uid)
            if not user_data:
                logger.warning(f"User ID {uid} found by get_all_users but not found by get_user. Skipping.")
                continue
            name = user_data.get("name", "–ë–µ–∑ –∏–º–µ–Ω–∏")
            username = user_data.get("username", "–ù–µ—Ç –Ω–∏–∫–Ω–µ–π–º–∞")
            last_action_time = "–ù–µ—Ç –¥–µ–π—Å—Ç–≤–∏–π"
            last_action_timestamp_iso_or_dt = "1970-01-01T00:00:00+00:00"
            user_actions = db.get_actions(uid)
            if user_actions:
                last_action = user_actions[-1]
                raw_timestamp = last_action.get("timestamp")
                try:
                    last_action_dt = None
                    if isinstance(raw_timestamp, datetime):
                         last_action_dt = raw_timestamp.astimezone(TIMEZONE) if raw_timestamp.tzinfo and pytz else (TIMEZONE.localize(raw_timestamp) if pytz else raw_timestamp)
                         last_action_timestamp_iso_or_dt = raw_timestamp
                    elif isinstance(raw_timestamp, str):
                         last_action_dt = datetime.fromisoformat(raw_timestamp.replace('Z', '+00:00')).astimezone(TIMEZONE)
                         last_action_timestamp_iso_or_dt = raw_timestamp
                    else:
                         logger.warning(f"Invalid timestamp type for last action of user {uid}: {type(raw_timestamp)}")
                    if last_action_dt:
                         last_action_time = last_action_dt.strftime("%Y-%m-%d %H:%M")
                    else:
                         last_action_time = "–û—à–∏–±–∫–∞ –≤—Ä–µ–º–µ–Ω–∏"
                except (ValueError, TypeError) as e:
                    logger.warning(f"Error parsing last action timestamp for user {uid}: {raw_timestamp}, error: {e}")
                    last_action_time = f"–û—à–∏–±–∫–∞ ({raw_timestamp})"
                    last_action_timestamp_iso_or_dt = raw_timestamp if isinstance(raw_timestamp, str) else "1970-01-01T00:00:00+00:00"
            user_list.append({
                "uid": uid,
                "username": username,
                "name": name,
                "last_action_time": last_action_time,
                "last_action_timestamp_iso_or_dt": last_action_timestamp_iso_or_dt
            })
        try:
            user_list.sort(
                key=lambda x: (x["last_action_timestamp_iso_or_dt"].astimezone(TIMEZONE) if isinstance(x["last_action_timestamp_iso_or_dt"], datetime) and x["last_action_timestamp_iso_or_dt"].tzinfo
                                else datetime.fromisoformat(str(x["last_action_timestamp_iso_or_dt"]).replace('Z', '+00:00')).astimezone(TIMEZONE) if isinstance(x["last_action_timestamp_iso_or_dt"], str)
                                else datetime.min.replace(tzinfo=TIMEZONE)),
                reverse=True
            )
        except (ValueError, TypeError) as sort_err:
            logger.error(f"Error sorting user list by timestamp: {sort_err}. List may be unsorted.")
        formatted_list = [f"ID: <code>{user['uid']}</code> | @{user['username']} | {user['name']} | –ü–æ—Å–ª. –¥–µ–π—Å—Ç–≤–∏–µ: {user['last_action_time']}" for user in user_list]
        header = f"üë• <b>–°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π ({len(formatted_list)}):</b>\n(–û—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ –ø–æ –ø–æ—Å–ª–µ–¥–Ω–µ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏)\n\n"
        full_text = header + "\n".join(formatted_list)
        max_len = 4000
        if len(full_text) > max_len:
            current_chunk = header
            for line in formatted_list:
                if len(current_chunk) + len(line) + 1 > max_len:
                    await message.answer(current_chunk)
                    current_chunk = ""
                current_chunk += line + "\n"
            if current_chunk:
                await message.answer(current_chunk)
        else:
            await message.answer(full_text)
        await logger_service.log_action(user_id, "users_command")
    return wrapped_handler

def make_logs_handler(db, logger_service):
    async def wrapped_handler(message: types.Message):
        user_id = message.from_user.id
        if user_id != ADMIN_ID: await message.answer("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É."); return
        args = message.text.split()
        target_date_str = None
        target_date = None
        if len(args) > 1:
            target_date_str = args[1]
            try:
                target_date = datetime.strptime(target_date_str, "%Y-%m-%d").date()
            except ValueError:
                await message.answer("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç—ã. –ò—Å–ø–æ–ª—å–∑—É–π –ì–ì–ì–ì-–ú–ú-–î–î (–Ω–∞–ø—Ä–∏–º–µ—Ä, 2024-12-31).")
                return
        else:
            target_date = datetime.now(TIMEZONE).date()
            target_date_str = target_date.strftime("%Y-%m-%d")
        await logger_service.log_action(user_id, "logs_command", {"date": target_date_str})
        logs = db.get_actions()
        filtered_logs = []
        excluded_users = set(NO_LOGS_USERS) if NO_LOGS_USERS else set()
        for log in logs:
            log_timestamp_dt = None
            try:
                raw_timestamp = log.get("timestamp")
                if isinstance(raw_timestamp, datetime):
                     log_timestamp_dt = raw_timestamp.astimezone(TIMEZONE) if raw_timestamp.tzinfo and pytz else (TIMEZONE.localize(raw_timestamp) if pytz else raw_timestamp)
                elif isinstance(raw_timestamp, str):
                     log_timestamp_dt = datetime.fromisoformat(raw_timestamp.replace('Z', '+00:00')).astimezone(TIMEZONE)
                else:
                     logger.warning(f"Skipping log due to invalid timestamp type: {type(raw_timestamp)} in action {log.get('id')}")
                     continue
                if log_timestamp_dt.date() == target_date and log.get("user_id") not in excluded_users:
                    log["parsed_datetime"] = log_timestamp_dt
                    filtered_logs.append(log)
            except (ValueError, TypeError, KeyError) as e:
                logger.warning(f"Could not parse timestamp or missing data in log for admin view: {log}, error: {e}")
                continue
        if not filtered_logs:
            await message.answer(f"–õ–æ–≥–æ–≤ –∑–∞ {target_date_str} –Ω–µ –Ω–∞–π–¥–µ–Ω–æ (–∏–ª–∏ –≤—Å–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –∏—Å–∫–ª—é—á–µ–Ω—ã).")
            return
        log_lines = []
        for log in filtered_logs:
            ts_str = log["parsed_datetime"].strftime('%H:%M:%S')
            uid = log.get('user_id', 'N/A')
            action = log.get('action', 'N/A')
            details = log.get('details', {})
            details_str = ""
            if isinstance(details, dict) and details:
                safe_details = {k: str(v)[:50] + ('...' if len(str(v)) > 50 else '') for k, v in details.items()}
                details_str = ", ".join([f"{k}={v}" for k, v in safe_details.items()])
                details_str = f" ({details_str[:100]}{'...' if len(details_str) > 100 else ''})"
            elif isinstance(details, str):
                details_str = f" (Details: {details[:100]}{'...' if len(details) > 100 else ''})"
            log_lines.append(f"{ts_str} U:{uid} A:{action}{details_str}")
        header = f"üìú <b>–õ–æ–≥–∏ –∑–∞ {target_date_str} ({len(log_lines)} –∑–∞–ø–∏—Å–µ–π):</b>\n\n"
        full_text = header + "\n".join(log_lines)
        max_len = 4000
        if len(full_text) > max_len:
            current_chunk = header
            for line in log_lines:
                if len(current_chunk) + len(line) + 1 > max_len:
                    await message.answer(current_chunk)
                    current_chunk = ""
                current_chunk += line + "\n"
            if current_chunk:
                await message.answer(current_chunk)
        else:
            await message.answer(full_text)
    return wrapped_handler

# --- –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –≤–≤–æ–¥–∞ –∏–º–µ–Ω–∏ ---
def make_process_name_handler(db, logger_service, user_manager):
     async def wrapped_handler(message: types.Message, state: FSMContext):
         user_id = message.from_user.id
         name = message.text.strip()
         if not name: await message.answer("–ò–º—è –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º..."); return
         if len(name) > 50: await message.answer("–°–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–æ–µ –∏–º—è..."); return
         reserved_names = ["‚ú® –ö–∞—Ä—Ç–∞ –¥–Ω—è", "üíå –ü–æ–¥—Å–∫–∞–∑–∫–∞ –í—Å–µ–ª–µ–Ω–Ω–æ–π", "üåô –ò—Ç–æ–≥ –¥–Ω—è"]
         if name in reserved_names:
             await message.answer(f"–ò–º—è '{name}' –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –Ω–µ–ª—å–∑—è, –æ–Ω–æ —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å –∫–Ω–æ–ø–∫–æ–π –º–µ–Ω—é.")
             return
         await user_manager.set_name(user_id, name)
         await logger_service.log_action(user_id, "set_name", {"name": name})
         await message.answer(f"–ü—Ä–∏—è—Ç–Ω–æ –ø–æ–∑–Ω–∞–∫–æ–º–∏—Ç—å—Å—è, {name}! üòä\n–¢–µ–ø–µ—Ä—å –º–æ–∂–µ—à—å –≤—ã–±—Ä–∞—Ç—å –¥–µ–π—Å—Ç–≤–∏–µ –≤ –º–µ–Ω—é.", reply_markup=await get_main_menu(user_id, db))
         await state.clear()
     return wrapped_handler

def make_process_skip_name_handler(db, logger_service, user_manager):
     async def wrapped_handler(callback: types.CallbackQuery, state: FSMContext):
         user_id = callback.from_user.id
         await user_manager.set_name(user_id, "")
         await logger_service.log_action(user_id, "skip_name")
         try:
             await callback.message.edit_reply_markup(reply_markup=None)
         except Exception as e:
             logger.warning(f"Could not edit message on skip_name for user {user_id}: {e}")
         await callback.message.answer("–•–æ—Ä–æ—à–æ, –±—É–¥—É –æ–±—Ä–∞—â–∞—Ç—å—Å—è –∫ —Ç–µ–±–µ –±–µ–∑ –∏–º–µ–Ω–∏.\n–í—ã–±–µ—Ä–∏ –¥–µ–π—Å—Ç–≤–∏–µ –≤ –º–µ–Ω—é.", reply_markup=await get_main_menu(user_id, db))
         await state.clear()
         await callback.answer()
     return wrapped_handler

# --- –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –≤–≤–æ–¥–∞ —Ñ–∏–¥–±–µ–∫–∞ ---
def make_process_feedback_handler(db, logger_service):
      async def wrapped_handler(message: types.Message, state: FSMContext):
          user_id = message.from_user.id
          feedback_text = message.text.strip()
          if not feedback_text: await message.answer("–ö–∞–∂–µ—Ç—Å—è, —Ç—ã –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞–ø–∏—Å–∞–ª–∞..."); return
          user_data = db.get_user(user_id)
          name = user_data.get("name", "–ê–Ω–æ–Ω–∏–º")
          username = user_data.get("username", "N/A")
          timestamp_iso = datetime.now(TIMEZONE).isoformat()
          try:
              with db.conn:
                  db.conn.execute("INSERT INTO feedback (user_id, name, feedback, timestamp) VALUES (?, ?, ?, ?)",
                                   (user_id, name, feedback_text, timestamp_iso))
              await logger_service.log_action(user_id, "feedback_submitted", {"feedback_length": len(feedback_text)})
              await message.answer(f"{name}, —Å–ø–∞—Å–∏–±–æ –∑–∞ —Ç–≤–æ–π –æ—Ç–∑—ã–≤! üôè", reply_markup=await get_main_menu(user_id, db))
              try:
                  admin_notify_text = (f"üìù –ù–æ–≤—ã–π —Ñ–∏–¥–±–µ–∫ –æ—Ç:\nID: <code>{user_id}</code>\n–ò–º—è: {name}\n–ù–∏–∫: @{username}\n\n<b>–¢–µ–∫—Å—Ç:</b>\n{feedback_text}")
                  await bot.send_message(ADMIN_ID, admin_notify_text[:4090])
              except Exception as admin_err:
                  logger.error(f"Failed to send feedback notification to admin: {admin_err}")
              await state.clear()
          except sqlite3.Error as db_err:
              logger.error(f"Failed to save feedback from user {user_id} to DB: {db_err}", exc_info=True)
              await message.answer("–û–π, –Ω–µ –ø–æ–ª—É—á–∏–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ç–≤–æ–π –æ—Ç–∑—ã–≤...", reply_markup=await get_main_menu(user_id, db))
              await state.clear()
      return wrapped_handler

# --- –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –±–æ–Ω—É—Å–∞ ---
def make_bonus_request_handler(db, logger_service, user_manager):
     async def wrapped_handler(message: types.Message):
         user_id = message.from_user.id
         user_data = db.get_user(user_id)
         name = user_data.get("name", "–î—Ä—É–≥")
         if not user_data.get("bonus_available"):
             text = f"{name}, —ç—Ç–∞ –ø–æ–¥—Å–∫–∞–∑–∫–∞ –ø–æ–∫–∞ –Ω–µ –¥–æ—Å—Ç—É–ø–Ω–∞. –ü–æ–¥–µ–ª–∏—Å—å —Å–≤–æ–µ–π —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–æ–π —Å—Å—ã–ª–∫–æ–π (/share) —Å –¥—Ä—É–≥–æ–º, —á—Ç–æ–±—ã –µ–µ –ø–æ–ª—É—á–∏—Ç—å! ‚ú®"
             await message.answer(text, reply_markup=await get_main_menu(user_id, db))
             return
         advice = random.choice(UNIVERSE_ADVICE)
         text = f"{name}, –≤–æ—Ç –ø–æ—Å–ª–∞–Ω–∏–µ –í—Å–µ–ª–µ–Ω–Ω–æ–π –¥–ª—è —Ç–µ–±—è:\n\n<i>{advice}</i>"
         await message.answer(text, reply_markup=await get_main_menu(user_id, db))
         await logger_service.log_action(user_id, "bonus_request_used", {"advice_preview": advice[:50]})
     return wrapped_handler

# --- –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –≤—Å–µ—Ö –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ ---
def register_handlers(dp: Dispatcher, db: Database, logger_service: LoggingService, user_manager: UserManager):
    logger.info("Registering handlers...")
    start_handler = make_start_handler(db, logger_service, user_manager)
    share_handler = make_share_handler(db, logger_service)
    remind_handler = make_remind_handler(db, logger_service, user_manager)
    remind_off_handler = make_remind_off_handler(db, logger_service, user_manager)
    process_morning_reminder_time_handler = make_process_morning_reminder_time_handler(db, logger_service, user_manager)
    process_evening_reminder_time_handler = make_process_evening_reminder_time_handler(db, logger_service, user_manager)
    name_handler = make_name_handler(db, logger_service, user_manager)
    process_name_handler = make_process_name_handler(db, logger_service, user_manager)
    process_skip_name_handler = make_process_skip_name_handler(db, logger_service, user_manager)
    feedback_handler = make_feedback_handler(db, logger_service)
    process_feedback_handler = make_process_feedback_handler(db, logger_service)
    user_profile_handler = make_user_profile_handler(db, logger_service)
    bonus_request_handler = make_bonus_request_handler(db, logger_service, user_manager)
    users_handler = make_users_handler(db, logger_service)
    logs_handler = make_logs_handler(db, logger_service)
    admin_user_profile_handler = make_admin_user_profile_handler(db, logger_service)
    broadcast_handler = make_broadcast_handler(db, logger_service)

    dp.message.register(start_handler, Command("start"), StateFilter("*"))
    dp.message.register(share_handler, Command("share"), StateFilter("*"))
    dp.message.register(remind_handler, Command("remind"), StateFilter("*"))
    dp.message.register(remind_off_handler, Command("remind_off"), StateFilter("*"))
    dp.message.register(name_handler, Command("name"), StateFilter("*"))
    dp.message.register(feedback_handler, Command("feedback"), StateFilter("*"))
    dp.message.register(user_profile_handler, Command("user_profile"), StateFilter("*"))
    dp.message.register(users_handler, Command("users"), StateFilter("*"))
    dp.message.register(logs_handler, Command("logs"), StateFilter("*"))
    dp.message.register(admin_user_profile_handler, Command("admin_user_profile"), StateFilter("*"))
    dp.message.register(broadcast_handler, Command("broadcast"), StateFilter("*"))

    dp.message.register(bonus_request_handler, F.text == "üíå –ü–æ–¥—Å–∫–∞–∑–∫–∞ –í—Å–µ–ª–µ–Ω–Ω–æ–π", StateFilter("*"))
    dp.message.register(partial(handle_card_request, db=db, logger_service=logger_service), F.text == "‚ú® –ö–∞—Ä—Ç–∞ –¥–Ω—è", StateFilter("*"))
    dp.message.register(partial(start_evening_reflection, db=db, logger_service=logger_service), F.text == "üåô –ò—Ç–æ–≥ –¥–Ω—è", StateFilter("*"))
    
    dp.message.register(process_name_handler, UserState.waiting_for_name)
    dp.callback_query.register(process_skip_name_handler, F.data == "skip_name", UserState.waiting_for_name)
    dp.message.register(process_feedback_handler, UserState.waiting_for_feedback)

    dp.message.register(process_morning_reminder_time_handler, UserState.waiting_for_morning_reminder_time)
    dp.message.register(process_evening_reminder_time_handler, UserState.waiting_for_evening_reminder_time)

    dp.callback_query.register(partial(process_initial_resource_callback, db=db, logger_service=logging_service), UserState.waiting_for_initial_resource, F.data.startswith("resource_"))
    dp.callback_query.register(partial(process_request_type_callback, db=db, logger_service=logging_service), UserState.waiting_for_request_type_choice, F.data.startswith("request_type_"))
    dp.message.register(partial(process_request_text, db=db, logger_service=logging_service), UserState.waiting_for_request_text_input)
    dp.message.register(partial(process_initial_response, db=db, logger_service=logging_service), UserState.waiting_for_initial_response)
    dp.callback_query.register(partial(process_exploration_choice_callback, db=db, logger_service=logging_service), UserState.waiting_for_exploration_choice, F.data.startswith("explore_"))
    dp.message.register(partial(process_first_grok_response, db=db, logger_service=logging_service), UserState.waiting_for_first_grok_response)
    dp.message.register(partial(process_second_grok_response, db=db, logger_service=logging_service), UserState.waiting_for_second_grok_response)
    dp.message.register(partial(process_third_grok_response, db=db, logger_service=logging_service), UserState.waiting_for_third_grok_response)
    dp.callback_query.register(partial(process_final_resource_callback, db=db, logger_service=logging_service), UserState.waiting_for_final_resource, F.data.startswith("resource_"))
    dp.message.register(partial(process_recharge_method, db=db, logger_service=logging_service), UserState.waiting_for_recharge_method)
    dp.callback_query.register(partial(process_card_feedback, db=db, logger_service=logging_service), F.data.startswith("feedback_v2_"), StateFilter("*"))

    dp.message.register(partial(process_good_moments, db=db, logger_service=logger_service), UserState.waiting_for_good_moments)
    dp.message.register(partial(process_gratitude, db=db, logger_service=logger_service), UserState.waiting_for_gratitude)
    dp.message.register(partial(process_hard_moments, db=db, logger_service=logger_service), UserState.waiting_for_hard_moments)

    async def handle_text_when_waiting_callback(message: types.Message, state: FSMContext):
        current_state = await state.get_state()
        logger.warning(f"User {message.from_user.id} sent text '{message.text}' while in state {current_state}, expected callback.")
        await message.reply("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏ –¥–ª—è —ç—Ç–æ–≥–æ —à–∞–≥–∞.")

    async def handle_callback_when_waiting_text(callback: types.CallbackQuery, state: FSMContext):
        current_state = await state.get_state()
        logger.warning(f"User {callback.from_user.id} sent callback '{callback.data}' while in state {current_state}, expected text.")
        await callback.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å –æ—Ç–≤–µ—Ç —Ç–µ–∫—Å—Ç–æ–º...", show_alert=True)

    dp.message.register(handle_text_when_waiting_callback, StateFilter(
        UserState.waiting_for_initial_resource,
        UserState.waiting_for_request_type_choice,
        UserState.waiting_for_exploration_choice,
        UserState.waiting_for_final_resource
    ))
    dp.callback_query.register(handle_callback_when_waiting_text, StateFilter(
        UserState.waiting_for_name,
        UserState.waiting_for_request_text_input,
        UserState.waiting_for_initial_response,
        UserState.waiting_for_first_grok_response,
        UserState.waiting_for_second_grok_response,
        UserState.waiting_for_third_grok_response,
        UserState.waiting_for_recharge_method,
        UserState.waiting_for_feedback,
        UserState.waiting_for_morning_reminder_time,
        UserState.waiting_for_evening_reminder_time,
        UserState.waiting_for_good_moments,
        UserState.waiting_for_gratitude,
        UserState.waiting_for_hard_moments
    ))

    # --- –ò–ó–ú–ï–ù–ï–ù–ò–ï: –î–æ—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –ª–æ–≥–≥–∏—Ä–æ–≤–∞–Ω–∏—è "–æ—Ç–≤–∞–ª–æ–≤" ---
    @dp.message(StateFilter("*"))
    async def handle_unknown_message_state(message: types.Message, state: FSMContext):
        user_id = message.from_user.id
        current_state_str = await state.get_state()
        logger.warning(f"Unknown message '{message.text}' from user {user_id} in state {current_state_str}")
        
        fsm_data = await state.get_data()
        session_id = fsm_data.get("session_id", "unknown_abandon")

        state_to_event_map = {
            UserState.waiting_for_initial_resource: "flow_abandoned_at_initial_resource",
            UserState.waiting_for_request_type_choice: "flow_abandoned_at_request_type",
            UserState.waiting_for_request_text_input: "flow_abandoned_at_request_input",
            UserState.waiting_for_initial_response: "flow_abandoned_at_initial_response",
            UserState.waiting_for_exploration_choice: "flow_abandoned_at_exploration_choice",
            UserState.waiting_for_first_grok_response: "flow_abandoned_at_grok_1",
            UserState.waiting_for_second_grok_response: "flow_abandoned_at_grok_2",
            UserState.waiting_for_third_grok_response: "flow_abandoned_at_grok_3",
            UserState.waiting_for_final_resource: "flow_abandoned_at_final_resource",
            UserState.waiting_for_recharge_method: "flow_abandoned_at_recharge"
        }
        
        event_name = state_to_event_map.get(current_state_str)
        if event_name:
            await logger_service.log_action(
                user_id,
                event_name,
                {
                    "user_input": message.text[:200],
                    "session_id": session_id
                }
            )

        await message.reply("–û–π, –∫–∞–∂–µ—Ç—Å—è, —è –Ω–µ –æ–∂–∏–¥–∞–ª —ç—Ç–æ–≥–æ —Å–µ–π—á–∞—Å... –ü–æ–ø—Ä–æ–±—É–π –≤–µ—Ä–Ω—É—Ç—å—Å—è —á–µ—Ä–µ–∑ /start –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π –∫–æ–º–∞–Ω–¥—É –∏–∑ –º–µ–Ω—é.")
        await state.clear()
    # --- –ö–û–ù–ï–¶ –ò–ó–ú–ï–ù–ï–ù–ò–Ø ---

    @dp.message()
    async def handle_unknown_message_no_state(message: types.Message):
        logger.warning(f"Unknown message '{message.text}' from user {message.from_user.id} with no state.")

    @dp.callback_query(StateFilter("*"))
    async def handle_unknown_callback_state(callback: types.CallbackQuery, state: FSMContext):
        logger.warning(f"Unknown callback '{callback.data}' from user {callback.from_user.id} in state {await state.get_state()}")
        await callback.answer("–≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ —Å–µ–π—á–∞—Å –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ.", show_alert=True)

    @dp.callback_query()
    async def handle_unknown_callback_no_state(callback: types.CallbackQuery):
        logger.warning(f"Unknown callback '{callback.data}' from user {callback.from_user.id} with no state.")
        await callback.answer("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ.", show_alert=True)

    logger.info("Handlers registered successfully.")


# --- –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ ---
async def main():
    logger.info("Starting bot...")
    commands = [
        types.BotCommand(command="start", description="üîÑ –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–∞"),
        types.BotCommand(command="name", description="üë©üèº –£–∫–∞–∑–∞—Ç—å –∏–º—è"),
        types.BotCommand(command="remind", description="‚è∞ –ù–∞—Å—Ç—Ä–æ–∏—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è"),
        types.BotCommand(command="remind_off", description="üîï –í—ã–∫–ª—é—á–∏—Ç—å –≤—Å–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è"),
        types.BotCommand(command="share", description="üéÅ –ü–æ–¥–µ–ª–∏—Ç—å—Å—è —Å –¥—Ä—É–≥–æ–º"),
        types.BotCommand(command="feedback", description="‚úâÔ∏è –û—Å—Ç–∞–≤–∏—Ç—å –æ—Ç–∑—ã–≤ / –ò–¥–µ—é"),
        types.BotCommand(command="user_profile", description="üìä –ú–æ–π –ø—Ä–æ—Ñ–∏–ª—å")
    ]
    try:
        await bot.set_my_commands(commands)
        logger.info("Bot commands set successfully.")
    except Exception as e:
        logger.error(f"Failed to set bot commands: {e}")

    dp["db"] = db
    dp["logger_service"] = logging_service
    dp["user_manager"] = user_manager
    register_handlers(dp, db, logging_service, user_manager)
    reminder_task = asyncio.create_task(notifier.check_reminders())
    logger.info("Reminder check task scheduled.")
    logger.info("Starting polling...")
    print("Bot is starting polling...")
    try:
        await dp.start_polling(bot, allowed_updates=dp.resolve_used_update_types())
    except Exception as e:
        logger.critical(f"Polling failed: {e}", exc_info=True)
        print(f"CRITICAL: Polling failed: {e}")
    finally:
        logger.info("Stopping bot...")
        print("Bot is stopping...")
        reminder_task.cancel()
        try:
            await reminder_task
        except asyncio.CancelledError:
            logger.info("Reminder task cancelled successfully.")
        if db and db.conn:
            try:
                db.close()
            except Exception as db_close_err:
                logger.error(f"Error closing database connection: {db_close_err}")
        logger.info("Bot session cleanup (handled by aiogram).")
        print("Bot stopped.")

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except (KeyboardInterrupt, SystemExit):
        logger.info("Bot stopped manually.")
    except Exception as e:
        logger.critical(f"Critical error in main execution: {e}", exc_info=True)
        print(f"CRITICAL error in main execution: {e}")
