import asyncio
from aiogram import Bot, Dispatcher, types
from aiogram.filters import Command
from aiogram.enums import ParseMode
from aiogram.client.default import DefaultBotProperties
from aiogram.fsm.context import FSMContext
from aiogram.fsm.storage.memory import MemoryStorage
from config import TOKEN, CHANNEL_ID, ADMIN_ID, UNIVERSE_ADVICE, BOT_LINK, TIMEZONE, NO_LOGS_USERS 
from database.db import Database
from modules.logging_service import LoggingService
from modules.notification_service import NotificationService
from modules.card_of_the_day import handle_card_request, draw_card, process_request_text, process_initial_response, process_first_grok_response, process_second_grok_response, process_third_grok_response, process_card_feedback, get_main_menu
from modules.user_management import UserState, UserManager
import random
from datetime import datetime, timedelta  # –î–æ–±–∞–≤–ª—è–µ–º timedelta
import os

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
bot = Bot(token=TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
storage = MemoryStorage()
dp = Dispatcher(storage=storage)
db_path = "/data/bot.db"
print(f"Checking if database file exists at {db_path}: {os.path.exists(db_path)}")
db = Database(path=db_path)
print(f"Database initialized at {db.conn}")
logger = LoggingService(db)
notifier = NotificationService(bot, db)
user_manager = UserManager(db)

# –ü—Ä–æ–≤–µ—Ä–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
try:
    db.get_user(0)
    print("Database check successful")
except Exception as e:
    logger.log_action(0, "db_init_error", {"error": str(e)})
    print(f"Database initialization failed: {e}")
    raise

# Middleware –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–¥–ø–∏—Å–∫–∏
class SubscriptionMiddleware:
    async def __call__(self, handler, event, data):
        if isinstance(event, types.Message):
            user_id = event.from_user.id
            if user_id == ADMIN_ID:  # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É –¥–ª—è –∞–¥–º–∏–Ω–∞
                return await handler(event, data)
            try:
                user_status = await bot.get_chat_member(CHANNEL_ID, user_id)
                if user_status.status not in ["member", "administrator", "creator"]:
                    name = db.get_user(user_id)["name"]
                    text = f"{name}, –ø—Ä–∏–≤–µ—Ç! –ü–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ <a href='https://t.me/TopPsyGame'>–∫–∞–Ω–∞–ª –∞–≤—Ç–æ—Ä–∞</a>!" if name else "–ü—Ä–∏–≤–µ—Ç! –ü–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ <a href='https://t.me/TopPsyGame'>–∫–∞–Ω–∞–ª –∞–≤—Ç–æ—Ä–∞</a>!"
                    await event.answer(text, disable_web_page_preview=True)
                    return
            except Exception:
                await event.answer("–û–π, —á—Ç–æ-—Ç–æ —Å–ª–æ–º–∞–ª–æ—Å—å... –ü–æ–ø—Ä–æ–±—É–π –ø–æ–∑–∂–µ.")
                return
        return await handler(event, data)

dp.message.middleware(SubscriptionMiddleware())

# –ö–æ–º–∞–Ω–¥–∞ /start
@dp.message(Command("start"))
async def start_command(message: types.Message, state: FSMContext):
    user_id = message.from_user.id
    username = message.from_user.username or ""  # –ü–æ–ª—É—á–∞–µ–º –Ω–∏–∫–Ω–µ–π–º –∏–∑ Telegram
    args = message.text.split(maxsplit=1)[1] if len(message.text.split()) > 1 else ""
    
    # –û–±–Ω–æ–≤–ª—è–µ–º username –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
    user_data = db.get_user(user_id)
    if user_data["username"] != username:  # –û–±–Ω–æ–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –Ω–∏–∫ –∏–∑–º–µ–Ω–∏–ª—Å—è
        user_data["username"] = username
        db.update_user(user_id, user_data)

    await logger.log_action(user_id, "start", {"args": args})

    if args.startswith("ref_"):
        referrer_id = int(args[4:])
        if referrer_id != user_id and user_id not in db.get_referrals(referrer_id):
            db.add_referral(referrer_id, user_id)
            if not db.get_user(referrer_id)["bonus_available"]:
                await user_manager.set_bonus_available(referrer_id, True)
                name = db.get_user(referrer_id)["name"]
                text = f"{name}, —É—Ä–∞! –ö—Ç–æ-—Ç–æ –æ—Ç–∫—Ä—ã–ª –∫–∞—Ä—Ç—É –ø–æ —Ç–≤–æ–µ–π —Å—Å—ã–ª–∫–µ! –í–æ–∑—å–º–∏ 'üíå –ü–æ–¥—Å–∫–∞–∑–∫—É –í—Å–µ–ª–µ–Ω–Ω–æ–π'." if name else "–£—Ä–∞! –ö—Ç–æ-—Ç–æ –æ—Ç–∫—Ä—ã–ª –∫–∞—Ä—Ç—É –ø–æ —Ç–≤–æ–µ–π —Å—Å—ã–ª–∫–µ! –í–æ–∑—å–º–∏ 'üíå –ü–æ–¥—Å–∫–∞–∑–∫—É –í—Å–µ–ª–µ–Ω–Ω–æ–π'."
                await bot.send_message(referrer_id, text, reply_markup=await get_main_menu(referrer_id, db))

    if not db.get_user(user_id)["name"]:
        await message.answer("–ü—Ä–∏–≤–µ—Ç! –î–∞–≤–∞–π –∑–Ω–∞–∫–æ–º–∏—Ç—å—Å—è! –ö–∞–∫ —Ç–µ–±—è –∑–æ–≤—É—Ç?", reply_markup=types.InlineKeyboardMarkup(inline_keyboard=[
            [types.InlineKeyboardButton(text="–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å", callback_data="skip_name")]
        ]))
        await state.set_state(UserState.waiting_for_name)
    else:
        name = db.get_user(user_id)["name"]
        await message.answer(f"{name}, —Ä–∞–¥–∞ —Ç–µ–±—è –≤–∏–¥–µ—Ç—å! –ù–∞–∂–º–∏ '‚ú® –ö–∞—Ä—Ç–∞ –¥–Ω—è'." if name else "–†–∞–¥–∞ —Ç–µ–±—è –≤–∏–¥–µ—Ç—å! –ù–∞–∂–º–∏ '‚ú® –ö–∞—Ä—Ç–∞ –¥–Ω—è'.", reply_markup=await get_main_menu(user_id, db))

# –ö–æ–º–∞–Ω–¥–∞ /share
@dp.message(Command("share"))
async def share_command(message: types.Message):
    user_id = message.from_user.id
    username = message.from_user.username or ""  # –ü–æ–ª—É—á–∞–µ–º –Ω–∏–∫–Ω–µ–π–º
    user_data = db.get_user(user_id)
    if user_data["username"] != username:
        user_data["username"] = username
        db.update_user(user_id, user_data)

    name = db.get_user(user_id)["name"]
    ref_link = f"{BOT_LINK}?start=ref_{user_id}"
    text = f"{name}, –ø–æ–¥–µ–ª–∏—Å—å: {ref_link}. –ï—Å–ª–∏ –∫—Ç–æ-—Ç–æ –∑–∞–π–¥—ë—Ç, –ø–æ–ª—É—á–∏—à—å 'üíå –ü–æ–¥—Å–∫–∞–∑–∫—É –í—Å–µ–ª–µ–Ω–Ω–æ–π'!" if name else f"–ü–æ–¥–µ–ª–∏—Å—å: {ref_link}. –ï—Å–ª–∏ –∫—Ç–æ-—Ç–æ –∑–∞–π–¥—ë—Ç, –ø–æ–ª—É—á–∏—à—å 'üíå –ü–æ–¥—Å–∫–∞–∑–∫—É –í—Å–µ–ª–µ–Ω–Ω–æ–π'!"
    await message.answer(text, reply_markup=await get_main_menu(user_id, db))

# –ö–æ–º–∞–Ω–¥–∞ /remind
@dp.message(Command("remind"))
async def remind_command(message: types.Message, state: FSMContext):
    user_id = message.from_user.id
    name = db.get_user(user_id)["name"]
    current_reminder = db.get_user(user_id)["reminder_time"] or "–Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ"
    text = f"{name}, —Ç–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è: {current_reminder}. –í–≤–µ–¥–∏ –Ω–æ–≤–æ–µ –≤—Ä–µ–º—è (—á—á:–º–º)." if name else f"–¢–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è: {current_reminder}. –í–≤–µ–¥–∏ –Ω–æ–≤–æ–µ –≤—Ä–µ–º—è (—á—á:–º–º)."
    await message.answer(text, reply_markup=await get_main_menu(user_id, db))
    await state.set_state(UserState.waiting_for_reminder_time)

# –ö–æ–º–∞–Ω–¥–∞ /users
@dp.message(Command("users"))
async def users_command(message: types.Message):
    user_id = message.from_user.id
    if user_id != ADMIN_ID:
        await message.answer("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
        return

    users = db.get_all_users()
    if not users:
        await message.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø–æ–∫–∞ –Ω–µ—Ç.")
        return

    # –§–∏–ª—å—Ç—Ä—É–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π, –∏—Å–∫–ª—é—á–∞—è NO_LOGS_USERS
    excluded_users = set(NO_LOGS_USERS)
    filtered_users = [uid for uid in users if uid not in excluded_users]
    if not filtered_users:
        await message.answer("–ù–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π, –∫—Ä–æ–º–µ –∏—Å–∫–ª—é—á—ë–Ω–Ω—ã—Ö.")
        return

    # –°–æ–±–∏—Ä–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è—Ö —Å —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–æ–π –ø–æ –ø–æ—Å–ª–µ–¥–Ω–µ–º—É –¥–µ–π—Å—Ç–≤–∏—é
    user_list = []
    for uid in filtered_users:
        user_data = db.get_user(uid)
        name = user_data["name"] or "–ë–µ–∑ –∏–º–µ–Ω–∏"
        username = user_data["username"] or "–ù–µ—Ç –Ω–∏–∫–Ω–µ–π–º–∞"
        
        # –ü–æ–ª—É—á–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–µ–µ –¥–µ–π—Å—Ç–≤–∏–µ –∏–∑ —Ç–∞–±–ª–∏—Ü—ã actions
        user_actions = db.get_actions(uid)
        last_action_time = "–ù–µ—Ç –¥–µ–π—Å—Ç–≤–∏–π"
        last_action_timestamp = "1970-01-01T00:00:00+00:00"  # –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏
        if user_actions:
            last_action = max(user_actions, key=lambda x: x["timestamp"])
            last_action_time = last_action["timestamp"]
            last_action_timestamp = last_action_time

        user_list.append({
            "uid": uid,
            "username": username,
            "name": name,
            "last_action_time": last_action_time,
            "last_action_timestamp": last_action_timestamp
        })

    # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ last_action_timestamp (–ø–æ –≤–æ–∑—Ä–∞—Å—Ç–∞–Ω–∏—é)
    user_list.sort(key=lambda x: x["last_action_timestamp"])

    # –§–æ—Ä–º–∏—Ä—É–µ–º —Å—Ç—Ä–æ–∫–∏ –¥–ª—è –≤—ã–≤–æ–¥–∞
    formatted_list = [
        f"ID: {user['uid']}, –ù–∏–∫: @{user['username']}, –ò–º—è: {user['name']}, –ü–æ—Å–ª–µ–¥–Ω–µ–µ –¥–µ–π—Å—Ç–≤–∏–µ: {user['last_action_time']}"
        for user in user_list
    ]

    # –†–∞–∑–±–∏–≤–∞–µ–º –Ω–∞ —á–∞—Å—Ç–∏, –µ—Å–ª–∏ —Å–ø–∏—Å–æ–∫ –¥–ª–∏–Ω–Ω—ã–π
    if len("\n".join(formatted_list)) > 4096:
        chunk_size = 10
        for i in range(0, len(formatted_list), chunk_size):
            chunk = formatted_list[i:i + chunk_size]
            chunk_text = f"–°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π (—á–∞—Å—Ç—å {i // chunk_size + 1}):\n" + "\n".join(chunk)
            await message.answer(chunk_text)
    else:
        text = "–°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:\n" + "\n".join(formatted_list)
        await message.answer(text)

# –ö–æ–º–∞–Ω–¥–∞ /feedback (—Å—Ç–∞—Ä–∞—è –ª–æ–≥–∏–∫–∞ —Å –∞–¥–∞–ø—Ç–∞—Ü–∏–µ–π –∫ SQLite)
@dp.message(Command("feedback"))
async def feedback_command(message: types.Message, state: FSMContext):
    user_id = message.from_user.id
    name = db.get_user(user_id)["name"]  # –ë–µ—Ä–µ–º –∏–º—è –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
    text = (
        f"{name}, –Ω–∞–ø–∏—à–∏ —Å–≤–æ–π –≤–æ–ø—Ä–æ—Å –∏–ª–∏ –∏–¥–µ—é, —á—Ç–æ–±—ã —è —Å–º–æ–≥ —Å—Ç–∞—Ç—å –µ—â—ë –ø–æ–ª–µ–∑–Ω–µ–µ. –Ø —Å–æ—Ö—Ä–∞–Ω—é –≤–∞—à–∏ –º—ã—Å–ª–∏!"
        if name
        else "–ù–∞–ø–∏—à–∏ —Å–≤–æ–π –≤–æ–ø—Ä–æ—Å –∏–ª–∏ –∏–¥–µ—é, —á—Ç–æ–±—ã —è —Å–º–æ–≥ —Å—Ç–∞—Ç—å –µ—â—ë –ø–æ–ª–µ–∑–Ω–µ–µ. –Ø —Å–æ—Ö—Ä–∞–Ω—é –≤–∞—à–∏ –º—ã—Å–ª–∏!"
    )
    await message.answer(
        text,
        reply_markup=await get_main_menu(user_id, db),  # –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è, –ø–æ—ç—Ç–æ–º—É await
        protect_content=True  # –ó–∞—â–∏—â–∞–µ–º –∫–æ–Ω—Ç–µ–Ω—Ç –æ—Ç –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è
    )
    await state.set_state(UserState.waiting_for_feedback)  # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –æ–∂–∏–¥–∞–Ω–∏—è –æ—Ç–∑—ã–≤–∞
    await logger.log_action(user_id, "feedback_initiated")

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–≤–æ–¥–∞ –æ—Ç–∑—ã–≤–∞
@dp.message(UserState.waiting_for_feedback)
async def process_feedback(message: types.Message, state: FSMContext):
    user_id = message.from_user.id
    feedback_text = message.text.strip()
    name = db.get_user(user_id)["name"]
    timestamp = datetime.now(TIMEZONE).isoformat()

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Ç–∑—ã–≤ –≤ —Ç–∞–±–ª–∏—Ü—É feedback
    with db.conn:
        db.conn.execute(
            "INSERT INTO feedback (user_id, name, feedback, timestamp) VALUES (?, ?, ?, ?)",
            (user_id, name, feedback_text, timestamp)
        )

    await logger.log_action(user_id, "feedback_submitted", {"feedback": feedback_text})
    text = f"{name}, —Å–ø–∞—Å–∏–±–æ –∑–∞ —Ç–≤–æ–π –æ—Ç–∑—ã–≤!" if name else "–°–ø–∞—Å–∏–±–æ –∑–∞ —Ç–≤–æ–π –æ—Ç–∑—ã–≤!"
    await message.answer(
        text,
        reply_markup=await get_main_menu(user_id, db),
        protect_content=True  # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∑–∞—â–∏—Ç—É –∫–æ–Ω—Ç–µ–Ω—Ç–∞
    )
    await state.clear()

# –ö–æ–º–∞–Ω–¥–∞ /name
@dp.message(Command("name"))
async def name_command(message: types.Message, state: FSMContext):
    user_id = message.from_user.id
    name = db.get_user(user_id)["name"]
    text = f"{name}, –∫–∞–∫ —Ç–µ–±—è –∑–æ–≤—É—Ç? –í–≤–µ–¥–∏ –Ω–æ–≤–æ–µ –∏–º—è –∏–ª–∏ '–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å'." if name else "–ö–∞–∫ —Ç–µ–±—è –∑–æ–≤—É—Ç? –í–≤–µ–¥–∏ –∏–º—è –∏–ª–∏ '–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å'."
    await message.answer(text, reply_markup=types.InlineKeyboardMarkup(inline_keyboard=[
        [types.InlineKeyboardButton(text="–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å", callback_data="skip_name")]
    ]))
    await state.set_state(UserState.waiting_for_name)

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–º–µ–Ω–∏
@dp.message(UserState.waiting_for_name)
async def process_name(message: types.Message, state: FSMContext):
    user_id = message.from_user.id
    name = message.text.strip()
    if name == "‚ú® –ö–∞—Ä—Ç–∞ –¥–Ω—è":  # –í–∞–ª–∏–¥–∞—Ü–∏—è –∏–º–µ–Ω–∏
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏ –¥—Ä—É–≥–æ–µ –∏–º—è. –≠—Ç–æ –∏–º—è –∑–∞—Ä–µ–∑–µ—Ä–≤–∏—Ä–æ–≤–∞–Ω–æ.")
        return
    await user_manager.set_name(user_id, name)
    await logger.log_action(user_id, "set_name", {"name": name})
    await message.answer(f"{name}, —Ä–∞–¥–∞ —Ç–µ–±—è –≤–∏–¥–µ—Ç—å! –ù–∞–∂–º–∏ '‚ú® –ö–∞—Ä—Ç–∞ –¥–Ω—è'.", reply_markup=await get_main_menu(user_id, db))
    await state.clear()

@dp.callback_query(lambda c: c.data == "skip_name")
async def process_skip_name(callback: types.CallbackQuery, state: FSMContext):
    user_id = callback.from_user.id
    await user_manager.set_name(user_id, "")
    await logger.log_action(user_id, "skip_name")
    await callback.message.answer("–•–æ—Ä–æ—à–æ, –±–µ–∑ –∏–º–µ–Ω–∏ —Ç–æ–∂–µ –∑–¥–æ—Ä–æ–≤–æ! –í—ã–±–µ—Ä–∏ '‚ú® –ö–∞—Ä—Ç–∞ –¥–Ω—è'!", reply_markup=await get_main_menu(user_id, db))
    await state.clear()
    await callback.answer()

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Ä–µ–º–µ–Ω–∏ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è
@dp.message(UserState.waiting_for_reminder_time)
async def process_reminder_time(message: types.Message, state: FSMContext):
    user_id = message.from_user.id
    name = db.get_user(user_id)["name"]
    reminder_time = message.text.strip()
    try:
        reminder_time_normalized = datetime.strptime(reminder_time, "%H:%M").strftime("%H:%M")
        await user_manager.set_reminder(user_id, reminder_time_normalized)
        await logger.log_action(user_id, "set_reminder_time", {"reminder_time": reminder_time_normalized})
        text = f"{name}, —è –±—É–¥—É –Ω–∞–ø–æ–º–∏–Ω–∞—Ç—å —Ç–µ–±–µ –≤ {reminder_time_normalized} –ø–æ –ú–æ—Å–∫–≤–µ." if name else f"–Ø –±—É–¥—É –Ω–∞–ø–æ–º–∏–Ω–∞—Ç—å —Ç–µ–±–µ –≤ {reminder_time_normalized} –ø–æ –ú–æ—Å–∫–≤–µ."
        await message.answer(text, reply_markup=await get_main_menu(user_id, db))
        await state.clear()
    except ValueError:
        text = f"{name}, –≤—Ä–µ–º—è —É–∫–∞–∑–∞–Ω–æ –Ω–µ–≤–µ—Ä–Ω–æ. –ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑ (—á—á:–º–º)." if name else "–í—Ä–µ–º—è —É–∫–∞–∑–∞–Ω–æ –Ω–µ–≤–µ—Ä–Ω–æ. –ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑ (—á—á:–º–º)."
        await message.answer(text, reply_markup=await get_main_menu(user_id, db))

# –ö–æ–º–∞–Ω–¥–∞ /check_logs –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ª–æ–≥–æ–≤
@dp.message(Command("logs"))
async def logs_command(message: types.Message):
    user_id = message.from_user.id
    if user_id != ADMIN_ID:
        await message.answer("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
        return

    args = message.text.split()
    if len(args) > 1:
        try:
            target_date = datetime.strptime(args[1], "%Y-%m-%d").date()
        except ValueError:
            await message.answer("–£–∫–∞–∂–∏—Ç–µ –¥–∞—Ç—É –≤ —Ñ–æ—Ä–º–∞—Ç–µ YYYY-MM-DD, –Ω–∞–ø—Ä–∏–º–µ—Ä: /logs 2025-04-07")
            return
    else:
        target_date = datetime.now(TIMEZONE).date()  # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é —Ç–µ–∫—É—â–∞—è –¥–∞—Ç–∞

    logs = db.get_actions()
    filtered_logs = []
    excluded_users = set(NO_LOGS_USERS)  # –ú–Ω–æ–∂–µ—Å—Ç–≤–æ –¥–ª—è –±—ã—Å—Ç—Ä–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏
    for log in logs:
        try:
            log_timestamp = datetime.fromisoformat(log["timestamp"]).astimezone(TIMEZONE)
            if log_timestamp.date() == target_date and log["user_id"] not in excluded_users:
                filtered_logs.append(log)
        except ValueError as e:
            await message.answer(f"–û—à–∏–±–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∞ –≤—Ä–µ–º–µ–Ω–∏ –≤ –ª–æ–≥–µ: {log['timestamp']}, –æ—à–∏–±–∫–∞: {e}")
            return

    if not filtered_logs:
        await message.answer(f"–õ–æ–≥–æ–≤ –∑–∞ {target_date} –Ω–µ—Ç.")
        return

    # –†–∞–∑–±–∏–≤–∞–µ–º –ª–æ–≥–∏ –Ω–∞ —á–∞—Å—Ç–∏ –ø–æ 20 –∑–∞–ø–∏—Å–µ–π
    chunk_size = 20
    for i in range(0, len(filtered_logs), chunk_size):
        chunk = filtered_logs[i:i + chunk_size]
        text = f"–õ–æ–≥–∏ –∑–∞ {target_date} (—á–∞—Å—Ç—å {i // chunk_size + 1}):\n"
        for log in chunk:
            text += f"User {log['user_id']}: {log['action']} at {log['timestamp']}, details: {log['details']}\n"
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–ª–∏–Ω—É —Ç–µ–∫—Å—Ç–∞ (–¥–ª—è –æ—Ç–ª–∞–¥–∫–∏, –º–æ–∂–Ω–æ —É–±—Ä–∞—Ç—å –ø–æ–∑–∂–µ)
        if len(text) > 4096:
            await message.answer("–°–æ–æ–±—â–µ–Ω–∏–µ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–æ–µ, —É–º–µ–Ω—å—à–∏—Ç–µ chunk_size.")
            return
        
        await message.answer(text)

# –§–∞–±—Ä–∏–∫–∏ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤
def make_card_request_handler(db, logger):
    async def wrapped_handler(message: types.Message, state: FSMContext):
        return await handle_card_request(message, state, db, logger)
    return wrapped_handler

def make_draw_card_handler(db, logger):
    async def wrapped_handler(callback: types.CallbackQuery, state: FSMContext):
        return await draw_card(callback, state, db, logger)
    return wrapped_handler

def make_process_request_text_handler(db, logger):
    async def wrapped_handler(message: types.Message, state: FSMContext):
        return await process_request_text(message, state, db, logger)
    return wrapped_handler

def make_process_initial_response_handler(db, logger):
    async def wrapped_handler(message: types.Message, state: FSMContext):
        return await process_initial_response(message, state, db, logger)
    return wrapped_handler

def make_process_first_grok_response_handler(db, logger):
    async def wrapped_handler(message: types.Message, state: FSMContext):
        return await process_first_grok_response(message, state, db, logger)
    return wrapped_handler

def make_process_second_grok_response_handler(db, logger):
    async def wrapped_handler(message: types.Message, state: FSMContext):
        return await process_second_grok_response(message, state, db, logger)
    return wrapped_handler

def make_process_third_grok_response_handler(db, logger):
    async def wrapped_handler(message: types.Message, state: FSMContext):
        return await process_third_grok_response(message, state, db, logger)
    return wrapped_handler

def make_process_card_feedback_handler(db, logger):
    async def wrapped_handler(callback: types.CallbackQuery, state: FSMContext):
        return await process_card_feedback(callback, state, db, logger)
    return wrapped_handler

# –û–±—Ä–∞–±–æ—Ç–∫–∞ "–ö–∞—Ä—Ç–∞ –¥–Ω—è"
dp.message.register(make_card_request_handler(db, logger), lambda m: m.text == "‚ú® –ö–∞—Ä—Ç–∞ –¥–Ω—è")
dp.callback_query.register(make_draw_card_handler(db, logger), lambda c: c.data == "draw_card")
dp.message.register(make_process_request_text_handler(db, logger), UserState.waiting_for_request_text)
dp.message.register(make_process_initial_response_handler(db, logger), UserState.waiting_for_initial_response)
dp.message.register(make_process_first_grok_response_handler(db, logger), UserState.waiting_for_first_grok_response)
dp.message.register(make_process_second_grok_response_handler(db, logger), UserState.waiting_for_second_grok_response)
dp.message.register(make_process_third_grok_response_handler(db, logger), UserState.waiting_for_third_grok_response)
dp.callback_query.register(make_process_card_feedback_handler(db, logger), lambda c: c.data.startswith("feedback_"))  # –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è feedback

# –û–±—Ä–∞–±–æ—Ç–∫–∞ "–ü–æ–¥—Å–∫–∞–∑–∫–∞ –í—Å–µ–ª–µ–Ω–Ω–æ–π"
@dp.message(lambda m: m.text == "üíå –ü–æ–¥—Å–∫–∞–∑–∫–∞ –í—Å–µ–ª–µ–Ω–Ω–æ–π")
async def handle_bonus_request(message: types.Message):
    user_id = message.from_user.id
    name = db.get_user(user_id)["name"]
    if not db.get_user(user_id)["bonus_available"]:
        text = f"{name}, —ç—Ç–æ—Ç —Å–æ–≤–µ—Ç –ø–æ–∫–∞ —Å–ø—Ä—è—Ç–∞–Ω! –ò—Å–ø–æ–ª—å–∑—É–π /share, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –µ–≥–æ." if name else "–≠—Ç–æ—Ç —Å–æ–≤–µ—Ç –ø–æ–∫–∞ —Å–ø—Ä—è—Ç–∞–Ω! –ò—Å–ø–æ–ª—å–∑—É–π /share, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –µ–≥–æ."
        await message.answer(text, reply_markup=await get_main_menu(user_id, db))
        return
    advice = random.choice(UNIVERSE_ADVICE)
    text = f"{name}, –≤–æ—Ç –ø–æ—Å–ª–∞–Ω–∏–µ –¥–ª—è —Ç–µ–±—è:\n{advice}" if name else f"–í–æ—Ç –ø–æ—Å–ª–∞–Ω–∏–µ –¥–ª—è —Ç–µ–±—è:\n{advice}"
    await message.answer(text, reply_markup=await get_main_menu(user_id, db))
    await logger.log_action(user_id, "bonus_request", {"advice": advice})

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
@dp.message()
async def handle_unknown_message(message: types.Message):
    await message.answer("–ò–∑–≤–∏–Ω–∏—Ç–µ, —è –Ω–µ –ø–æ–Ω—è–ª –≤–∞—à –∑–∞–ø—Ä–æ—Å. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –Ω–∞–∂–∞—Ç—å '‚ú® –ö–∞—Ä—Ç–∞ –¥–Ω—è' –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—ã /start, /name, /remind, /share, /feedback")

# –ó–∞–ø—É—Å–∫
async def main():
    try:
        db.bot = bot
        # –†–∞–∑–æ–≤–∞—è –º–∏–≥—Ä–∞—Ü–∏—è: –æ–±–Ω–æ–≤–ª—è–µ–º username –¥–ª—è –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
        users = db.get_all_users()
        for user_id in users:
            try:
                chat = await bot.get_chat(user_id)
                username = chat.username or ""
                user_data = db.get_user(user_id)
                if user_data["username"] != username:
                    user_data["username"] = username
                    db.update_user(user_id, user_data)
            except Exception as e:
                logger.log_action(user_id, "username_migration_error", {"error": str(e)})

        asyncio.create_task(notifier.check_reminders())
        broadcast_data = {
            "datetime": datetime.now(TIMEZONE).replace(second=0, microsecond=0) + timedelta(minutes=2),
            "text": "–¢–µ—Å—Ç–æ–≤–∞—è —Ä–∞—Å—Å—ã–ª–∫–∞",
            "recipients": [6682555021]
        }
        asyncio.create_task(notifier.send_broadcast(broadcast_data))
        while True:
            try:
                await dp.start_polling(bot)
                break
            except Exception as e:
                logger.log_action(0, "polling_error", {"error": str(e)})
                await asyncio.sleep(5)
    except Exception as e:
        logger.log_action(0, "main_error", {"error": str(e)})
        raise

if __name__ == "__main__":
    asyncio.run(main())
